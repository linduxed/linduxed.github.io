---
layout: post
title: "Code I enjoy"
date: Mon, 27 Feb 2012 17:59:41 +0000
comments: true
categories: tech
---
Being a CS student means that I will be forced to code in a variety of
languages. A lot of our code will be written in Java or C++, but we'll
necessarily get in touch with many other languages, spanning over multiple
paradigms.

By no means am I a good programmer yet, but the exposure to the different ways
of crafting code has led me to think about what I value (as a novice
programmer) in a language. It's, after all, my main tool of expression.  
Is it the brevity of the code? What the community surrounding the language is
like? Paradigm or strong vs. weak typing? Or could it be that I need the
language to be as “simple” as possible for me to be able to formulate ideas?

<!--more-->

## My roots, or the lack of them

My first language I got to code in was actually Borland Delphi. I didn't really
know what I was doing, I just followed a guide that let me create a “guess what
number I'm thinking of”-application with a GUI that I got to draw. I was
probably about ten years old at that time, and it wasn't until late elementary
that I got acquainted with Java, in a programming course.

Since a bit of Delphi was all I had under my belt at the time, Java was quite
the challenge at first. I didn't like the notion of there being things that
I had to write that I didn't fully understand the purpose of (the concept of
“static” was a prime example). Also, while I understood the necessity of
getters and setters, it felt weird that I had to write them everywhere;
I already had something against boilerplate.

Java has been with me for more than a decade, so I've gotten used to its
intricacies, but it wasn't the language that got me really interested in
programming.

## Inspiration and motivation

While I tried borrowing introductory books for both Java and C++, neither of
the languages really interested me. I felt that there was so much to learn,
just to accomplish the simplest of things. That's when a friend of mine
introduced me to Python.

The thing I immediately liked about Python was the brevity. To this day I find
that there's something special about seeing text no longer than a screen full
(very reminiscent of pseudo code, one might add) execute and work its magic.
It's empowering in a way, to so easily make so much happen. To let ideas
transform into code at such a quick rate becomes not only a tool, but
a motivation; when scraping together an application gets easier, the
imagination takes over.

Another thing that I hadn't experienced up until my encounter with Python was
easily readable code. I didn't know of the expression at that time, but
“self-documenting code” was something I really enjoyed; whether the names got
longer or the code had to be restructured, it was worth it for the readability.

Today it so happens that I code more Ruby than I do Python, but I still love
the language. Python both motivated and influenced me, but not to the extent
that Haskell did.

## A different way of doing things

Haskell is special to me because it showed me a totally different way of
crafting code while still keeping it short and expressive. Once I got past the
peculiarity of functional programming it made me re-evaluate what I'd consider
“comfortable” when I write code.

As soon as I got the taste for higher order functions, currying, lazy
evaluation and all of the other facilities that Haskell offers, I started to
think about why other languages hadn't introduced me to these concepts.

The thing I love the most about the language is that solving problems in it is
a satisfying experience. When the recursive thinking became more natural, and
I devoted the time to expand my vocabulary of functions that Haskell offered,
magic happened. A friend jokingly referred to Haskell as a “set of glorified
one-liners”, and while there's more to it than that, there's joy in crafting
those one-liners.

## Learning one's preferences

{% blockquote Alan J. Perlis, Epigrams on Programming %}
A language that doesn't affect the way you think about programming, is not worth knowing.
{% endblockquote %}

I can't say that I had the greatest time during my struggles with Prolog, or
that fighting with all the details one has to keep in his head when writing
Assembly was a pleasure, but it made me see things differently.

I guess it's a “coming of age” thing for a programmer to realize not what you
want to code, but how you want to do it.

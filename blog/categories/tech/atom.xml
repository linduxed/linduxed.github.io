<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: tech | Rants of a geek]]></title>
  <link href="http://linduxed.com/blog/categories/tech/atom.xml" rel="self"/>
  <link href="http://linduxed.com/"/>
  <updated>2014-06-22T12:33:06+02:00</updated>
  <id>http://linduxed.com/</id>
  <author>
    <name><![CDATA[linduxed]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Not ready for the switch]]></title>
    <link href="http://linduxed.com/blog/2012/05/10/not-ready-for-the-switch/"/>
    <updated>2012-05-10T14:12:25+02:00</updated>
    <id>http://linduxed.com/blog/2012/05/10/not-ready-for-the-switch</id>
    <content type="html"><![CDATA[<p>Yesterday, for some unknown reason, <a href="http://5digits.org/pentadactyl/">Pentadactyl</a> decided that it didn&rsquo;t want to work any more.
I still have no idea why, and since I&rsquo;ve been suspending my computer for quite
a few days now, it might actually have to do with me upgrading Firefox from 11
to 12 quite recently. The problem was actually pretty easily solved by
downloading the latest nightly and just fire that up, but before I did that, the
sudden loss of Vim-style navigation inspired me to pick up an old project of
mine:</p>

<p>Moving from Firefox to uzbl.</p>

<!--more-->


<h2>It sounds so beautiful</h2>

<p>For those who don&rsquo;t know what <a href="http://www.uzbl.org/">uzbl</a> is, it&rsquo;s basically
a browser that adheres to the UNIX philosophy of &ldquo;doing one thing and doing it
well&rdquo;. What that means is that the browser is split up into small pieces; you
have <code>uzbl-core</code> which is not much more than Webkit with some interfaces on top
of it, and the actual thing that resembles a browser is either <code>uzbl-browser</code> or
<code>uzbl-tabbed</code>.<br/>
You know you&rsquo;re in for a ride if the developers initially didn&rsquo;t have
<code>uzbl-tabbed</code> at all since &ldquo;window managers should be handling the different
instances of the browser, not the browser itself&rdquo;. All the basic functionality
that one takes for granted in other browsers that aren&rsquo;t strictly browsing are
extras here; bookmarks, downloading, completion and other functionality that you
come to expect are scripts that are loaded by the main configuration file.</p>

<h2>But the beauty comes at a price</h2>

<p>If the application is nice then I&rsquo;m willing to put the time into configuring it.
Whether it&rsquo;s my ZSH terminal, Vim, Firefox or something else, I&rsquo;ll put in the
work to get it <em>just right</em> if I know that I can get that magnificent end result
that I envision. uzbl sounds fantastic because I like the notion of being able
to configure a system from the ground up, to see what happens and to know what
does what.</p>

<p>There&rsquo;s just one big problem however:</p>

<p>The work necessary to get uzbl to the state my Firefox is in with the numerous
extensions and custom configurations would take <em>ages</em>, if at all possible.
I decided that I can try to live without NoScript, BetterPrivacy, Firebug and
some other nice extensions, as long as I get what I consider to be core
functionality to work smoothly. Even this (what I would consider modest)
aspiration is a challenge to say the least.</p>

<p>The default configuration gives you Vim-like control, with hjkl-movement and
some other things that you might recognize if you&rsquo;re coming from
Pentadactyl/Vimperator, but the similarities end fairly quickly. Once the basic
keys were reconfigured to my liking, one of the first things I wanted to tweak
was that since I use <code>uzbl_tabbed</code>, I&rsquo;ll want to reconfigure the <code>NEW_WINDOW</code>
action to load links in new tabs. The fact that only the action <code>NEW_TAB</code> worked
and not the other two potentially nice ones (<code>NEW_BG_TAB</code> and <code>NEW_BG_TAB_NEXT</code>)
was a shame, doubly so when there&rsquo;s no information for how get it to work.</p>

<h2>You&rsquo;re on your own</h2>

<p>This was the first encounter (out of many, I might add) with what eventually led
me to give up on the browser. There&rsquo;s no comprehensive source of information
about uzbl… anywhere.</p>

<p>I use Archlinux on my main computer but I know that I might not have been if it
wasn&rsquo;t for the fantastic Wiki. I don&rsquo;t know if that huge source of information
has spoiled me, but I feel like I&rsquo;m done with the days of guessing myself forth
when configuring software. I don&rsquo;t enjoy being in the situation of “Well I&rsquo;d
really like to do foobar, so I guess I&rsquo;ll scour tens of config files to see if
someone has done something remotely similar from which I can extrapolate some
kind of solution”.</p>

<p><em>I&rsquo;m done with that shit.</em></p>

<p>The Arch Wiki proves that even if you put docstrings for every line in your
configuration, a Wiki page with some quick and helpful tweaks that every new
user would make, is a thousand times better. As soon as I got any idea on how
I&rsquo;d like to tweak the interface of uzbl, it was followed by the realization that
there&rsquo;s neither a quick nor an obvious way to do it.</p>

<p>The <a href="http://www.uzbl.org/wiki/">official Wiki</a> is so barren that it seems to be
made by and exclusively for the current/future developers. Google isn&rsquo;t much
more helpful, the usual searches for HOWTOs or tutorials yield not much more
information than what one would derive from the sample configs that one can find
in the Wiki.</p>

<h2>See you some other time</h2>

<p>The impression I get is that if you&rsquo;re not ready to figure it out, then you
shouldn&rsquo;t even start. I gave it quite a few hours and at a certain point decided
that fixing Pentadactyl would be far more beneficial and far less time
consuming.</p>

<p>Some day I&rsquo;ll probably give it another shot, but by that time I&rsquo;ll probably come
prepared with far more patience and without the expectation to actually replace
Firefox.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[When the tools just don't work]]></title>
    <link href="http://linduxed.com/blog/2012/03/15/when-the-tools-just-dont-work/"/>
    <updated>2012-03-15T12:38:30+01:00</updated>
    <id>http://linduxed.com/blog/2012/03/15/when-the-tools-just-dont-work</id>
    <content type="html"><![CDATA[<p>Every once in a while you stumble on that area of software that Linux just
doesn&rsquo;t have covered. You might now be thinking that I&rsquo;d like to talk about
audio and video editing. A fair guess, since you&rsquo;ll hear people talk about
these two as areas where the other platforms have significantly more
sophisticated software available. But this isn&rsquo;t what I&rsquo;m going to talk about.</p>

<!--more-->


<p>You see, I&rsquo;ve had a look at the video and audio editors out there for Linux, and
while it&rsquo;s generally not as good as what you&rsquo;d have on OSX or Windows, there are
projects that make honest efforts to compete (Rosegarden comes to mind). I think
even the cynics can at least call the tools in these areas “rudimentary”.</p>

<p>“Streaming your desktop” in Linux, however, is one area you can&rsquo;t even fucking
call rudimentary. The appropriate description I&rsquo;ve come up with is “technically
working with the help of wizardry”, and I&rsquo;m thinking about whether that&rsquo;s too
generous.</p>

<h2>No audience</h2>

<p>I can&rsquo;t say I&rsquo;m particularly surprised by this situation, because apart from the
occasional recorded screen cast for some brand new package, there isn&rsquo;t that
much of a need, it seems. We don&rsquo;t have the games to stream, which I would
assume is a large part of what drives the revenue of a page like Justin.tv.</p>

<p>I assume most of the people who code in Linux aren&rsquo;t exactly eager to stream and
narrate their work, which could have been that “other area” of content that
would have driven the development of tools for streaming. I understand that the
Linux community might have less scenarios under which one would want to stream
one&rsquo;s desktop, but I&rsquo;m still surprised by how dire the software situation is.</p>

<h2>The tools</h2>

<p>From what I&rsquo;ve gathered, the most “mature” application available for handling
the various aspects of streaming (sound, picture, overlays and so on) is
WebcamStudio, which didn&rsquo;t exactly work. At the best of times it was giving me
something that looked like the stream I wanted to pass on, but I never managed
to actually get any streaming site to accept the data. This completely sidesteps
the issue that is the buggy-as-fuck interface, that neither looks good nor works
well.</p>

<p>The most stable solution I&rsquo;ve found, that has actually let me see my desktop on
the internet, is the combination of:</p>

<ul>
<li>Letting VLC capture your desktop with a wide array of flags to make sure it
comes out right. Figuring out those was a ton of fun.</li>
<li>Having a script called “jtvlc” catch the data and send it in through the
Justin.tv API.</li>
</ul>


<p>It&rsquo;s way better than nothing, but this gives me absolutely no ability to
customize the output, except choosing what part of my monitor set-up it should
grab.</p>

<h2>Conclusion</h2>

<p>In a way, I hope I&rsquo;ve missed something; I hope there&rsquo;s an obscure package that
simply grabs the part of the desktop you want, has a nice interface, and just
works. If that magic package exists however, then I haven&rsquo;t found it.</p>

<p>There are times when I really would have liked to share the view of one of my
screens, with some embedded microphone commentary. When the ideas pop up, I&rsquo;d
like to go ahead and just try them out, but in this case, I&rsquo;m completely
hindered. It might be that the process of getting these things to work under the
other systems is also a chore, but at least I&rsquo;ve seen plenty examples of there
being an end result. That&rsquo;s something I&rsquo;ve yet to see here in Linux.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Code I enjoy]]></title>
    <link href="http://linduxed.com/blog/2012/02/27/code-i-enjoy/"/>
    <updated>2012-02-27T18:59:41+01:00</updated>
    <id>http://linduxed.com/blog/2012/02/27/code-i-enjoy</id>
    <content type="html"><![CDATA[<p>Being a CS student means that I will be forced to code in a variety of
languages. A lot of our code will be written in Java or C++, but we&rsquo;ll
necessarily get in touch with many other languages, spanning over multiple
paradigms.</p>

<p>By no means am I a good programmer yet, but the exposure to the different ways
of crafting code has led me to think about what I value (as a novice
programmer) in a language. It&rsquo;s, after all, my main tool of expression.<br/>
Is it the brevity of the code? What the community surrounding the language is
like? Paradigm or strong vs. weak typing? Or could it be that I need the
language to be as “simple” as possible for me to be able to formulate ideas?</p>

<!--more-->


<h2>My roots, or the lack of them</h2>

<p>My first language I got to code in was actually Borland Delphi. I didn&rsquo;t really
know what I was doing, I just followed a guide that let me create a “guess what
number I&rsquo;m thinking of”-application with a GUI that I got to draw. I was
probably about ten years old at that time, and it wasn&rsquo;t until late elementary
that I got acquainted with Java, in a programming course.</p>

<p>Since a bit of Delphi was all I had under my belt at the time, Java was quite
the challenge at first. I didn&rsquo;t like the notion of there being things that
I had to write that I didn&rsquo;t fully understand the purpose of (the concept of
“static” was a prime example). Also, while I understood the necessity of
getters and setters, it felt weird that I had to write them everywhere;
I already had something against boilerplate.</p>

<p>Java has been with me for more than a decade, so I&rsquo;ve gotten used to its
intricacies, but it wasn&rsquo;t the language that got me really interested in
programming.</p>

<h2>Inspiration and motivation</h2>

<p>While I tried borrowing introductory books for both Java and C++, neither of
the languages really interested me. I felt that there was so much to learn,
just to accomplish the simplest of things. That&rsquo;s when a friend of mine
introduced me to Python.</p>

<p>The thing I immediately liked about Python was the brevity. To this day I find
that there&rsquo;s something special about seeing text no longer than a screen full
(very reminiscent of pseudo code, one might add) execute and work its magic.
It&rsquo;s empowering in a way, to so easily make so much happen. To let ideas
transform into code at such a quick rate becomes not only a tool, but
a motivation; when scraping together an application gets easier, the
imagination takes over.</p>

<p>Another thing that I hadn&rsquo;t experienced up until my encounter with Python was
easily readable code. I didn&rsquo;t know of the expression at that time, but
“self-documenting code” was something I really enjoyed; whether the names got
longer or the code had to be restructured, it was worth it for the readability.</p>

<p>Today it so happens that I code more Ruby than I do Python, but I still love
the language. Python both motivated and influenced me, but not to the extent
that Haskell did.</p>

<h2>A different way of doing things</h2>

<p>Haskell is special to me because it showed me a totally different way of
crafting code while still keeping it short and expressive. Once I got past the
peculiarity of functional programming it made me re-evaluate what I&rsquo;d consider
“comfortable” when I write code.</p>

<p>As soon as I got the taste for higher order functions, currying, lazy
evaluation and all of the other facilities that Haskell offers, I started to
think about why other languages hadn&rsquo;t introduced me to these concepts.</p>

<p>The thing I love the most about the language is that solving problems in it is
a satisfying experience. When the recursive thinking became more natural, and
I devoted the time to expand my vocabulary of functions that Haskell offered,
magic happened. A friend jokingly referred to Haskell as a “set of glorified
one-liners”, and while there&rsquo;s more to it than that, there&rsquo;s joy in crafting
those one-liners.</p>

<h2>Learning one&rsquo;s preferences</h2>

<p><blockquote><p>A language that doesn&rsquo;t affect the way you think about programming, is not worth knowing.</p><footer><strong>Alan J. Perlis</strong> <cite>Epigrams on Programming</cite></footer></blockquote></p>

<p>I can&rsquo;t say that I had the greatest time during my struggles with Prolog, or
that fighting with all the details one has to keep in his head when writing
Assembly was a pleasure, but it made me see things differently.</p>

<p>I guess it&rsquo;s a “coming of age” thing for a programmer to realize not what you
want to code, but how you want to do it.</p>
]]></content>
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: tech | Rants of a geek]]></title>
  <link href="http://linduxed.com/blog/categories/tech/atom.xml" rel="self"/>
  <link href="http://linduxed.com/"/>
  <updated>2014-06-22T00:47:47+02:00</updated>
  <id>http://linduxed.com/</id>
  <author>
    <name><![CDATA[linduxed]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Code I enjoy]]></title>
    <link href="http://linduxed.com/blog/2012/02/27/code-i-enjoy/"/>
    <updated>2012-02-27T18:59:41+01:00</updated>
    <id>http://linduxed.com/blog/2012/02/27/code-i-enjoy</id>
    <content type="html"><![CDATA[<p>Being a CS student means that I will be forced to code in a variety of
languages. A lot of our code will be written in Java or C++, but we&rsquo;ll
necessarily get in touch with many other languages, spanning over multiple
paradigms.</p>

<p>By no means am I a good programmer yet, but the exposure to the different ways
of crafting code has led me to think about what I value (as a novice
programmer) in a language. It&rsquo;s, after all, my main tool of expression.<br/>
Is it the brevity of the code? What the community surrounding the language is
like? Paradigm or strong vs. weak typing? Or could it be that I need the
language to be as “simple” as possible for me to be able to formulate ideas?</p>

<!--more-->


<h2>My roots, or the lack of them</h2>

<p>My first language I got to code in was actually Borland Delphi. I didn&rsquo;t really
know what I was doing, I just followed a guide that let me create a “guess what
number I&rsquo;m thinking of”-application with a GUI that I got to draw. I was
probably about ten years old at that time, and it wasn&rsquo;t until late elementary
that I got acquainted with Java, in a programming course.</p>

<p>Since a bit of Delphi was all I had under my belt at the time, Java was quite
the challenge at first. I didn&rsquo;t like the notion of there being things that
I had to write that I didn&rsquo;t fully understand the purpose of (the concept of
“static” was a prime example). Also, while I understood the necessity of
getters and setters, it felt weird that I had to write them everywhere;
I already had something against boilerplate.</p>

<p>Java has been with me for more than a decade, so I&rsquo;ve gotten used to its
intricacies, but it wasn&rsquo;t the language that got me really interested in
programming.</p>

<h2>Inspiration and motivation</h2>

<p>While I tried borrowing introductory books for both Java and C++, neither of
the languages really interested me. I felt that there was so much to learn,
just to accomplish the simplest of things. That&rsquo;s when a friend of mine
introduced me to Python.</p>

<p>The thing I immediately liked about Python was the brevity. To this day I find
that there&rsquo;s something special about seeing text no longer than a screen full
(very reminiscent of pseudo code, one might add) execute and work its magic.
It&rsquo;s empowering in a way, to so easily make so much happen. To let ideas
transform into code at such a quick rate becomes not only a tool, but
a motivation; when scraping together an application gets easier, the
imagination takes over.</p>

<p>Another thing that I hadn&rsquo;t experienced up until my encounter with Python was
easily readable code. I didn&rsquo;t know of the expression at that time, but
“self-documenting code” was something I really enjoyed; whether the names got
longer or the code had to be restructured, it was worth it for the readability.</p>

<p>Today it so happens that I code more Ruby than I do Python, but I still love
the language. Python both motivated and influenced me, but not to the extent
that Haskell did.</p>

<h2>A different way of doing things</h2>

<p>Haskell is special to me because it showed me a totally different way of
crafting code while still keeping it short and expressive. Once I got past the
peculiarity of functional programming it made me re-evaluate what I&rsquo;d consider
“comfortable” when I write code.</p>

<p>As soon as I got the taste for higher order functions, currying, lazy
evaluation and all of the other facilities that Haskell offers, I started to
think about why other languages hadn&rsquo;t introduced me to these concepts.</p>

<p>The thing I love the most about the language is that solving problems in it is
a satisfying experience. When the recursive thinking became more natural, and
I devoted the time to expand my vocabulary of functions that Haskell offered,
magic happened. A friend jokingly referred to Haskell as a “set of glorified
one-liners”, and while there&rsquo;s more to it than that, there&rsquo;s joy in crafting
those one-liners.</p>

<h2>Learning one&rsquo;s preferences</h2>

<p><blockquote><p>A language that doesn&rsquo;t affect the way you think about programming, is not worth knowing.</p><footer><strong>Alan J. Perlis</strong> <cite>Epigrams on Programming</cite></footer></blockquote></p>

<p>I can&rsquo;t say that I had the greatest time during my struggles with Prolog, or
that fighting with all the details one has to keep in his head when writing
Assembly was a pleasure, but it made me see things differently.</p>

<p>I guess it&rsquo;s a “coming of age” thing for a programmer to realize not what you
want to code, but how you want to do it.</p>
]]></content>
  </entry>
  
</feed>
